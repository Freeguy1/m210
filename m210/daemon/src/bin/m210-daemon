#!/usr/bin/python
# -*- coding: utf-8 -*-

# Standard modules.
import errno
import os
import os.path
import signal
import sys
import syslog

# Third-party modules.
import dbus
import dbus.service
import dbus.mainloop.glib

import PyQt4.QtCore

# Project-specific modules.
import m210.collections
import m210.daemon
import m210.input
import m210.optparse
import m210.pegatech

USAGE='%prog [OPTION]'

def find_m210_devpaths():
    find_cmd = r"""
find /sys/devices/pci0000\:00 -type d \
-execdir grep -q 0e20 '{}'/idVendor \; \
-execdir grep -q 0101 '{}'/idProduct \; \
-print 2>/dev/null
"""
    
    return os.popen(find_cmd).read().strip().splitlines()

def udev_root():
    return os.popen("udevadm info --root").read().strip().splitlines()[0]

def find_m210_paths(devpath):
    find_cmd = r"""
find %s -iregex .*%s[0-9][0-9]*$ | sed 's/.*\(%s[0-9][0-9]*\)/\1/'
"""
    
    find_hidraw = find_cmd % (devpath, "hidraw", "hidraw")
    hidraw_names = os.popen(find_hidraw).read().strip().splitlines()
    hidraw_paths = [os.path.join(udev_root(), name) for name in hidraw_names]
    
    find_event = find_cmd % (devpath, "event", "event")
    event_name = os.popen(find_event).read().strip().splitlines()[0]
    event_path = os.path.join(udev_root(), "input", event_name)
    
    return hidraw_paths[0], hidraw_paths[1], event_path

class M210Connection(object):

    def __init__(self, devpath):
        hidraw0, hidraw1, event = find_m210_paths(devpath)
        self._event_fd = None
        self._event_fd = os.open(event, os.O_RDWR)
        m210.input.grab_event_device(self._event_fd)
        self.m210 = m210.pegatech.M210((hidraw0, hidraw1))

    def __del__(self):
        if self._event_fd is not None:
            # self._event_fd might be None if self.__init__ fails for
            # some reason.
            m210.input.release_event_device(self._event_fd)

class Daemon(dbus.service.Object):

    def __init__(self, bus):
        dbus.service.Object.__init__(self, bus, m210.daemon.OBJECT_PATH)
        self._connection_map = m210.collections.OrderedDict()

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='s')
    def connect(self, devpath):
        self._connection_map[devpath] = M210Connection(devpath)
        self.device_connected(devpath)

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='s')
    def disconnect(self, devpath):
        self._connection_map.pop(devpath)
        self.device_disconnected(devpath)

    @dbus.service.method(m210.daemon.INTERFACE, out_signature='as')
    def connected_devpaths(self):
        return self._connection_map.keys()

    @dbus.service.method(m210.daemon.INTERFACE, out_signature='as')
    def disconnected_devpaths(self):
        result = []
        connected_devpaths = self.connected_devpaths()
        for devpath in find_m210_devpaths():
            if devpath not in connected_devpaths:
                result.append(devpath)
        return result

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='ss',
                         out_signature='i')
    def download_notes(self, devpath, filename):
        f = open(filename, "wb")
        try:
            return self._connection_map[devpath].m210.download_notes_to(f)
        finally:
            f.close()

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='s')
    def delete_notes(self, devpath):
        self._connection_map[devpath].m210.delete_notes()
        self.device_erased(devpath)

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='s',
                         out_signature='a{si}')
    def get_info(self, devpath):
        return self._connection_map[devpath].m210.get_info()

    @dbus.service.signal(m210.daemon.INTERFACE, signature='s')
    def device_connected(self, devpath):
        pass

    @dbus.service.signal(m210.daemon.INTERFACE, signature='s')
    def device_disconnected(self, devpath):
        pass

    @dbus.service.signal(m210.daemon.INTERFACE, signature='s')
    def device_erased(self, devpath):
        pass

def parse_args():
    parser = m210.optparse.OptionParser(usage=USAGE)
    parser.add_option('', '--no-daemon', action='store_false',
                      default=True, dest='daemon',
                      help='do not run as a daemon')
    return parser.parse_args(sys.argv)

def daemonize(syslog_options=syslog.LOG_PID | syslog.LOG_CONS):
    """Summon a quite proper Linux daemon process quite properly.

    1. Fork and exit parent.

    2. Create a new session.

    3. Ignore SIGHUP.

    4. Fork and exit parent again.

    5. Clear umask.

    6. Change current directory to /.

    7. Close all file descriptors.

    8. Open new files for sys.stdin, sys.stdout and sys.stderr.

    9. Redirect them to /dev/null.

    10. Optionally open syslog if syslog_options is not None. Default
    syslog_options is syslog.LOG_PID | syslog.LOG_CONS.
 
    """

    if os.fork():
        os._exit(0)
    else:
        os.setsid()
        signal.signal(signal.SIGHUP, signal.SIG_IGN)
        if os.fork():
            os._exit(0)
    os.umask(0)
    os.chdir('/')

    # Close all file descriptors inherited from the parent process.
    for i in range(os.sysconf('SC_OPEN_MAX')):
        try:
            os.close(i)
        except OSError, e:
            if e.errno == errno.EBADF:
                continue # Ignore if the file descriptor does not exists.
            raise e # Other exceptions shall fly through.
            
    # Close old standard file objects and open new ones. open() is
    # guaranteed to allocate lowest available file descriptor, that
    # means 0, 1, 2 because all file descriptors were just closed.
    sys.stdin.close()
    sys.stdin = open(os.devnull, sys.stdin.mode)
    sys.stdout.close()
    sys.stdout = open(os.devnull, sys.stdout.mode)
    sys.stderr.close()
    sys.stderr = open(os.devnull, sys.stderr.mode)

    if syslog_options is not None:
        syslog.openlog(os.path.basename(sys.argv[0]), syslog_options,
                       syslog.LOG_DAEMON)

def main():
    options, args = parse_args()

    if options.daemon:
        daemonize()

    # Integrate to glib-mainloop. For some reason, DBusQtMainLoop does
    # not work.
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

    # Open a bus.
    bus = dbus.SystemBus()

    # Register a well-known name for the service.
    name = dbus.service.BusName(m210.daemon.NAME, bus)

    # Export a daemon object through the bus.
    daemon = Daemon(bus)

    app = PyQt4.QtCore.QCoreApplication([])
    app.exec_()

if __name__ == '__main__':
    main()
