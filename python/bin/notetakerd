#!/usr/bin/python
# -*- coding: utf-8 -*-

# Standard modules.
import optparse
import os
import sys

# Third-party modules.
import dbus
import dbus.service
import dbus.mainloop.glib

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

import PyQt4.QtCore

# Project-specific modules.
import linux
import linux.input
import notetaker.pegatech

SERVICE_NAME = 'org.codegrove.notetaker'
DAEMON_INTERFACE_NAME = 'org.codegrove.notetaker.daemon'

class M210Connection(object):

    def __init__(self, dirpath):
        hidraw0_path, hidraw1_path, event_path = find_m210_paths(dirpath)
        self._event_fd = None
        self._event_fd = os.open(event_path, os.O_RDWR)
        linux.input.grab_event_device(self._event_fd)
        self.m210 = notetaker.pegatech.M210((hidraw0_path, hidraw1_path))

    def __del__(self):
        if self._event_fd is not None:
            # self._event_fd might be None if self.__init__ fails for
            # some reason.
            linux.input.release_event_device(self._event_fd)

def find_m210_dirpaths():
    find_cmd = r"""
find /sys/devices/pci0000\:00 -type d \
-execdir grep -q 0e20 '{}'/idVendor \; \
-execdir grep -q 0101 '{}'/idProduct \; \
-print 2>/dev/null
"""
    
    return os.popen(find_cmd).read().strip().splitlines()

def udev_root():
    return os.popen("udevadm info --root").read().strip().splitlines()[0]

def find_m210_paths(dirpath):
    find_cmd = r"""
find %s -iregex .*%s[0-9][0-9]*$ | sed 's/.*\(%s[0-9][0-9]*\)/\1/'
"""
    
    find_hidraw = find_cmd % (dirpath, "hidraw", "hidraw")
    hidraw_names = os.popen(find_hidraw).read().strip().splitlines()
    hidraw_paths = [os.path.join(udev_root(), name) for name in hidraw_names]
    
    find_event = find_cmd % (dirpath, "event", "event")
    event_name = os.popen(find_event).read().strip().splitlines()[0]
    event_path = os.path.join(udev_root(), "input", event_name)
    
    return hidraw_paths[0], hidraw_paths[1], event_path

class Daemon(dbus.service.Object):

    OBJECT_PATH = '/org/codegrove/notetaker/daemon'

    def __init__(self, bus):
        dbus.service.Object.__init__(self, bus, Daemon.OBJECT_PATH)
        self._connections = {}

    @dbus.service.method(DAEMON_INTERFACE_NAME, in_signature='s')
    def connect(self, dirpath):
        if dirpath in self._connections:
            raise ValueError("%s is already connected" % dirpath)
        self._connections[dirpath] = M210Connection(dirpath)

    @dbus.service.method(DAEMON_INTERFACE_NAME, in_signature='s')
    def disconnect(self, dirpath):
        self._connections.pop(dirpath)

    @dbus.service.method(DAEMON_INTERFACE_NAME, out_signature='as')
    def connections(self):
        return list(self._connections.keys())

def parse_args():
    parser = optparse.OptionParser(version='''%s 0.1
Copyright (C) 2010 Tuomas (tuos) R채s채nen <tuos@codegrove.org>
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Tuomas R채s채nen.''' % (linux.PROGRAM_INVOCATION_SHORT_NAME))
    parser.add_option('', '--no-daemon', action='store_false',
                      default=True, dest='daemon',
                      help='do not run %s as a daemon'
                      % linux.PROGRAM_INVOCATION_SHORT_NAME)
    return parser.parse_args(sys.argv)

def main():
    options, args = parse_args()

    if options.daemon:
        linux.daemonize()

    # Integrate to glib-mainloop. For some reason, DBusQtMainLoop does
    # not work.
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

    # Open a bus.
    bus = dbus.SystemBus()

    # Register a well-known name for the service.
    name = dbus.service.BusName(SERVICE_NAME, bus)

    # Export a daemon object through the bus.
    daemon = Daemon(bus)

    app = PyQt4.QtCore.QCoreApplication([])
    app.exec_()

if __name__ == '__main__':
    main()
