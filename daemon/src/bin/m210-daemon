#!/usr/bin/python
# -*- coding: utf-8 -*-

# m210
# Copyright © 2010 Tuomas Räsänen (tuos) <tuos@codegrove.org>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import division

# Standard modules.
import errno
import os
import os.path
import signal
import sys
import syslog

# Third-party modules.
import dbus
import dbus.service
import dbus.mainloop.glib

import PyQt4.QtCore

# Project-specific modules.
import m210.collections
import m210.daemon
import m210.input
import m210.optparse
import m210.pegatech

USAGE='%prog [OPTION]'

def find_m210_devpaths():
    find_cmd = r"""
find /sys/devices/pci0000\:00 -type d \
-execdir grep -q 0e20 '{}'/idVendor \; \
-execdir grep -q 0101 '{}'/idProduct \; \
-print 2>/dev/null
"""
    
    return os.popen(find_cmd).read().strip().splitlines()

def udev_root():
    return os.popen("udevadm info --root").read().strip().splitlines()[0]

def find_m210_paths(devpath):
    find_cmd = r"""
find %s -iregex .*%s[0-9][0-9]*$ | sed 's/.*\(%s[0-9][0-9]*\)/\1/'
"""
    
    find_hidraw = find_cmd % (devpath, "hidraw", "hidraw")
    hidraw_names = os.popen(find_hidraw).read().strip().splitlines()
    hidraw_paths = [os.path.join(udev_root(), name) for name in hidraw_names]
    
    find_event = find_cmd % (devpath, "event", "event")
    event_name = os.popen(find_event).read().strip().splitlines()[0]
    event_path = os.path.join(udev_root(), "input", event_name)
    
    return hidraw_paths[0], hidraw_paths[1], event_path

class M210Connection(object):

    def __init__(self, devpath):
        hidraw0, hidraw1, event = find_m210_paths(devpath)
        self._event_fd = None
        self._event_fd = os.open(event, os.O_RDWR)
        m210.input.grab_event_device(self._event_fd)
        self.m210 = m210.pegatech.M210((hidraw0, hidraw1))

    def __del__(self):
        if self._event_fd is not None:
            # self._event_fd might be None if self.__init__ fails for
            # some reason.
            m210.input.release_event_device(self._event_fd)

class Daemon(dbus.service.Object):

    def __init__(self, bus):
        self._connection_map = m210.collections.OrderedDict()
        for devpath in find_m210_devpaths():
            self._connection_map[devpath] = None
        bus.add_signal_receiver(self.device_added, "device_added")
        bus.add_signal_receiver(self.device_removed, "device_removed")
        dbus.service.Object.__init__(self, bus, m210.daemon.OBJECT_PATH)

    def device_added(self, devpath):
        self._connection_map[devpath] = None
        self.device_plugged(devpath)

    def device_removed(self, devpath):
        try:
            self._connection_map.pop(devpath)
        except KeyError:
            pass
        else:
            self.device_unplugged(devpath)

    def get_connection(self, devpath):
        try:
            conn = self._connection_map[devpath]
        except KeyError:
            raise m210.daemon.UnknownDeviceError(devpath)
        if conn is None:
            raise m210.daemon.NotConnectedError(devpath)
        return conn

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='s')
    def connect(self, devpath):
        try:
            self.get_connection(devpath)
        except m210.daemon.NotConnectedError:
            self._connection_map[devpath] = M210Connection(devpath)
            self.device_connected(devpath)
        else:
            raise m210.daemon.AlreadyConnectedError(devpath)

    @dbus.service.method(m210.daemon.INTERFACE, out_signature='as')
    def connect_all(self):
        result = []
        for devpath in self._connection_map:
            try:
                self.connect(devpath)
            except m210.daemon.AlreadyConnectedError:
                continue
            result.append(devpath)
        return result

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='s')
    def disconnect(self, devpath):
        self.get_connection(devpath)
        self._connection_map[devpath] = None
        self.device_disconnected(devpath)

    @dbus.service.method(m210.daemon.INTERFACE, out_signature='as')
    def disconnect_all(self):
        result = []
        for devpath in self._connection_map:
            try:
                self.disconnect(devpath)
            except m210.daemon.NotConnectedError:
                continue
            result.append(devpath)
        return result

    @dbus.service.method(m210.daemon.INTERFACE, out_signature='a(sb)')
    def devpaths(self):
        return [(k, v is not None) for (k, v) in self._connection_map.items()]

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='ss',
                         out_signature='i')
    def download_notes(self, devpath, filename):
        f = open(filename, "wb")
        try:
            return self.get_connection(devpath).m210.download_notes_to(f)
        finally:
            f.close()

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='ss')
    def set_mode(self, devpath, new_mode):
        self.get_connection(devpath).m210.set_mode(new_mode)
        self.device_mode_changed(devpath, new_mode)

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='sis')
    def set_tablet_settings(self, devpath, size, orientation):
        self.get_connection(devpath).m210.set_tablet_settings(size, orientation)

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='s')
    def delete_notes(self, devpath):
        self.get_connection(devpath).m210.delete_notes()
        self.device_erased(devpath)

    @dbus.service.method(m210.daemon.INTERFACE, in_signature='s',
                         out_signature='iiisi')
    def get_info(self, devpath):
        info = self.get_connection(devpath).m210.get_info()
        return info['firmware_version'], info['analog_version'], info['pad_version'], info['mode'], info['used_memory']

    @dbus.service.signal(m210.daemon.INTERFACE, signature='s')
    def device_plugged(self, devpath):
        pass

    @dbus.service.signal(m210.daemon.INTERFACE, signature='s')
    def device_unplugged(self, devpath):
        pass

    @dbus.service.signal(m210.daemon.INTERFACE, signature='s')
    def device_connected(self, devpath):
        pass

    @dbus.service.signal(m210.daemon.INTERFACE, signature='s')
    def device_disconnected(self, devpath):
        pass

    @dbus.service.signal(m210.daemon.INTERFACE, signature='s')
    def device_erased(self, devpath):
        pass

    @dbus.service.signal(m210.daemon.INTERFACE, signature='ss')
    def device_mode_changed(self, devpath, new_mode):
        pass

def parse_args():
    parser = m210.optparse.OptionParser(usage=USAGE)
    parser.add_option('', '--no-daemon', action='store_false',
                      default=True, dest='daemon',
                      help='do not run as a daemon')
    return parser.parse_args(sys.argv)

def daemonize(syslog_options=syslog.LOG_PID | syslog.LOG_CONS):
    """Summon a quite proper Linux daemon process quite properly.

    1. Fork and exit parent.

    2. Create a new session.

    3. Ignore SIGHUP.

    4. Fork and exit parent again.

    5. Clear umask.

    6. Change current directory to /.

    7. Close all file descriptors.

    8. Open new files for sys.stdin, sys.stdout and sys.stderr.

    9. Redirect them to /dev/null.

    10. Optionally open syslog if syslog_options is not None. Default
    syslog_options is syslog.LOG_PID | syslog.LOG_CONS.
 
    """

    if os.fork():
        os._exit(0)
    else:
        os.setsid()
        signal.signal(signal.SIGHUP, signal.SIG_IGN)
        if os.fork():
            os._exit(0)
    os.umask(0)
    os.chdir('/')

    # Close all file descriptors inherited from the parent process.
    for i in range(os.sysconf('SC_OPEN_MAX')):
        try:
            os.close(i)
        except OSError, e:
            if e.errno == errno.EBADF:
                continue # Ignore if the file descriptor does not exists.
            raise e # Other exceptions shall fly through.
            
    # Close old standard file objects and open new ones. open() is
    # guaranteed to allocate lowest available file descriptor, that
    # means 0, 1, 2 because all file descriptors were just closed.
    sys.stdin.close()
    sys.stdin = open(os.devnull, sys.stdin.mode)
    sys.stdout.close()
    sys.stdout = open(os.devnull, sys.stdout.mode)
    sys.stderr.close()
    sys.stderr = open(os.devnull, sys.stderr.mode)

    if syslog_options is not None:
        syslog.openlog(os.path.basename(sys.argv[0]), syslog_options,
                       syslog.LOG_DAEMON)

def main():
    options, args = parse_args()

    if options.daemon:
        daemonize()

    # Integrate to glib-mainloop. For some reason, DBusQtMainLoop does
    # not work.
    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)

    # Open a bus.
    bus = dbus.SystemBus()

    # Register a well-known name for the service.
    name = dbus.service.BusName(m210.daemon.NAME, bus)

    # Export a daemon object through the bus.
    daemon = Daemon(bus)

    app = PyQt4.QtCore.QCoreApplication([])
    sys.exit(app.exec_())

if __name__ == '__main__':
    try:
        main()
    except BaseException, e:
        syslog.syslog(syslog.LOG_ERR, str(e))
