#!/usr/bin/python
# -*- coding: utf-8 -*-

# m210c-qt
# Copyright © 2010 Tuomas Räsänen (tuos) <tuos@codegrove.org>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import division

import functools
import os
import sys
import zipfile

import dbus.mainloop.qt
dbus.mainloop.qt.DBusQtMainLoop(set_as_default=True)

from PyQt4.QtCore import pyqtSignal
from PyQt4.QtCore import Qt
from PyQt4.QtCore import QObject
from PyQt4.QtCore import QVariant
from PyQt4.QtGui import QApplication
from PyQt4.QtGui import QMainWindow
from PyQt4.QtGui import QFileDialog
from PyQt4.QtGui import QMessageBox
from PyQt4.QtGui import QListWidgetItem
from PyQt4.QtGui import QCheckBox
from PyQt4.QtGui import QAbstractSpinBox
from PyQt4.QtGui import QSpinBox

from m210.qt.ui.mainwindow import Ui_MainWindow
import m210.daemon
import m210.pegatech

import m210.qt.dataview

class MainWindow(QMainWindow, Ui_MainWindow):

    def __init__(self, *args):
        QMainWindow.__init__(self, *args)
        self.setupUi(self)
        self.dataview = m210.qt.dataview.DataView(self)
        self.horizontalLayoutDataView.addWidget(self.dataview)
        self.daemon = m210.daemon.Interface()
        self.row_map = {}

        self.listWidget.itemSelectionChanged.connect(
            self.list_selection_changed)
        self.listWidget.itemDoubleClicked.connect(
            self.list_item_double_clicked)
        self.daemon.connect_to_signal("device_plugged",
                                      self.dbusev_device_plugged)
        self.daemon.connect_to_signal("device_unplugged",
                                      self.dbusev_device_unplugged)
        self.daemon.connect_to_signal("device_connected",
                                      functools.partial(
                self.dbusev_device_managed_changed, True))
        self.daemon.connect_to_signal("device_disconnected",
                                      functools.partial(
                self.dbusev_device_managed_changed, False))
        self.daemon.connect_to_signal("device_erased",
                                      self.dbusev_device_erased)
        self.daemon.connect_to_signal("device_mode_changed",
                                      self.dbusev_device_mode_changed)
        self.comboBoxMode.currentIndexChanged[str].connect(
            self.combo_box_mode_changed)
        self.pushButtonEraseAll.clicked.connect(self.erase_all_clicked)
        self.pushButtonSaveAll.clicked.connect(self.save_all_clicked)
        self.pushButtonConfigureTablet.clicked.connect(
            self.configure_tablet_clicked)

        for devpath, is_managed in self.daemon.devpaths():
            self.dbusev_device_plugged(devpath)
            if is_managed:
                self.dbusev_device_managed_changed(True, devpath)

    def list_item_double_clicked(self, item):
        item_is_managed = item.data(Qt.CheckStateRole).toBool()
        devpath = unicode(item.data(Qt.DisplayRole).toString())
        if item_is_managed:
            self.daemon.disconnect(devpath)
        else:
            self.daemon.connect(devpath)

    def combo_box_mode_changed(self, mode):
        is_tablet_mode = mode == "TABLET"
        self.comboBoxOrientation.setVisible(is_tablet_mode)
        self.spinBoxSize.setVisible(is_tablet_mode)
        self.labelSize.setVisible(is_tablet_mode)
        self.labelOrientation.setVisible(is_tablet_mode)
        self.pushButtonConfigureTablet.setVisible(is_tablet_mode)
        devpath = self.selected_devpath()
        new_mode = unicode(self.comboBoxMode.currentText())
        self.daemon.set_mode(devpath, new_mode)
        self.statusBar().showMessage("%s mode activated." % new_mode,
                                     msecs=5000)

    def configure_tablet_clicked(self):
        devpath = self.selected_devpath()
        size = self.spinBoxSize.value()
        orientation = unicode(self.comboBoxOrientation.currentText())
        self.daemon.set_tablet_settings(devpath, size, orientation)
        self.statusBar().showMessage("TABLET configured.",
                                     msecs=5000)

    def save_all_clicked(self):
        fname = QFileDialog.getSaveFileName(self, 
                                            caption="Select download target",
                                            directory=os.path.expanduser("~"),
                                            filter="Zip (*.zip)")
        fname = unicode(fname)
        if fname:
            devpath = self.selected_devpath()
            data = self.daemon.download_data(devpath, byte_arrays=True)
            zipf = zipfile.ZipFile(unicode(fname), "w")
            zipdirname = os.path.splitext(os.path.basename(fname))[0]
            zipf.writestr(os.path.join(zipdirname, "raw"), data)
            for note in m210.pegatech.note_iter_from_data(data):
                svgpath = os.path.join(zipdirname, str(note.number) + ".svg")
                zipf.writestr(svgpath, note.as_svg())

    def erase_all_clicked(self):
        result = QMessageBox.question(self, "Erase all notes?",
                                      "Are you sure you want to erase all notes stored in the device?",
                                      QMessageBox.Yes | QMessageBox.No,
                                      QMessageBox.No)
        if result == QMessageBox.Yes:
            devpath = self.selected_devpath()
            self.daemon.delete_notes(devpath)

    def list_selection_changed(self):
        self.update_group_box()

    def devpath_from_item(self, item):
        return unicode(item.data(Qt.DisplayRole).toString())

    def state_from_item(self, item):
        return bool(item.data(Qt.CheckStateRole).toBool())

    def selected_item(self):
        try:
            return self.listWidget.selectedItems()[0]
        except IndexError:
            return None

    def selected_devpath(self):
        return self.devpath_from_item(self.selected_item())

    def update_group_box(self):
        selected_item = self.selected_item()
        
        devpath = self.devpath_from_item(selected_item)
        self.groupBox.setTitle(devpath)

        item_state = self.state_from_item(selected_item)
        self.groupBox.setEnabled(item_state)

        try:
            data = self.daemon.download_data(devpath, byte_arrays=True)
            fw, analog, pad, mode, bytes = self.daemon.get_info(devpath)
            # TODO: size and orientation queries.
        except dbus.exceptions.DBusException, e:
            name = e.get_dbus_name()
            if name != "org.freedesktop.DBus.Python.m210.daemon.NotConnectedError":
                raise e
            data = None
            fw, analog, pad, mode, bytes = 0, 0, 0, "TABLET", 0
            # TODO: size and orientation defaults.

        self.dataview.set_data(data)

        self.spinBoxFirmware.setValue(fw)
        self.spinBoxAnalog.setValue(analog)
        self.spinBoxPad.setValue(pad)
        self.spinBoxMem.setValue(bytes)
        index = self.comboBoxMode.findText(mode)
        self.comboBoxMode.setCurrentIndex(index)
        self.groupBoxInput.setChecked(True)

    def devpath_to_item(self, devpath):
        return self.listWidget.item(self.row_map[devpath])

    def dbusev_device_erased(self, devpath):
        if devpath == self.selected_devpath():
            self.pushButtonEraseAll.setEnabled(False)
            self.spinBoxMem.setValue(0)

    def dbusev_device_mode_changed(self, devpath, new_mode):
        if devpath == self.selected_devpath():
            index = self.comboBoxMode.findText(new_mode)
            self.comboBoxMode.setCurrentIndex(index)

    def dbusev_device_plugged(self, devpath):
        row = self.listWidget.count()
        item = QListWidgetItem(devpath, self.listWidget)
        item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        item.setCheckState(Qt.Unchecked)
        self.listWidget.addItem(item)
        self.row_map[devpath] = row
        item.setSelected(True)

    def dbusev_device_unplugged(self, devpath):
        self.listWidget.takeItem(self.row_map.pop(devpath))

    def dbusev_device_managed_changed(self, is_managed, devpath):
        item = self.devpath_to_item(devpath)
        if is_managed:
            item.setCheckState(Qt.Checked)
        else:
            item.setCheckState(Qt.Unchecked)
        self.update_group_box()

def main():
    app = QApplication(sys.argv)
    mw = MainWindow()
    mw.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
