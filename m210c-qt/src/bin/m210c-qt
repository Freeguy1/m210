#!/usr/bin/python
# -*- coding: utf-8 -*-

# m210c-qt
# Copyright © 2010 Tuomas Räsänen (tuos) <tuos@codegrove.org>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import division

import functools
import sys

import dbus.mainloop.qt
dbus.mainloop.qt.DBusQtMainLoop(set_as_default=True)

from PyQt4.QtCore import pyqtSignal
from PyQt4.QtCore import Qt
from PyQt4.QtCore import QObject
from PyQt4.QtCore import QVariant
from PyQt4.QtGui import QApplication
from PyQt4.QtGui import QMainWindow
from PyQt4.QtGui import QFileDialog
from PyQt4.QtGui import QMessageBox
from PyQt4.QtGui import QTableWidgetItem
from PyQt4.QtGui import QCheckBox

from m210.qt.ui.mainwindow import Ui_MainWindow
import m210.daemon

class MainWindow(QMainWindow, Ui_MainWindow):

    def __init__(self, *args):
        QMainWindow.__init__(self, *args)
        self.setupUi(self)
        self.actionDetails.setChecked(False)
        self.actionQuit.triggered.connect(self.close)
        self.menuFile.addAction(self.actionQuit)
        self.daemon = m210.daemon.Interface()
        self.current_mode = None
        self.row_map = {}

        self.tableWidget.itemSelectionChanged.connect(
            self.table_selection_changed)
        self.daemon.connect_to_signal("device_plugged", self.add_row)
        self.daemon.connect_to_signal("device_unplugged", self.remove_row)
        self.daemon.connect_to_signal("device_connected",
                                      functools.partial(
                self.device_connection_changed, True))
        self.daemon.connect_to_signal("device_disconnected",
                                      functools.partial(
                self.device_connection_changed, False))
        self.daemon.connect_to_signal("device_erased", self.device_erased)
        self.daemon.connect_to_signal("device_mode_changed",
                                      self.device_mode_changed)
        self.spinBoxUsedMemory.valueChanged.connect(self.used_mem_changed)
        self.pushButtonErase.clicked.connect(self.erase_clicked)
        self.pushButtonDownload.clicked.connect(self.download_clicked)
        self.pushButtonSetMode.clicked.connect(self.set_mode_clicked)
        self.comboBoxMode.currentIndexChanged[str].connect(
            self.desired_mode_changed)

        for devpath, connected in self.daemon.devpaths():
            self.add_row(devpath, connected)

    def desired_mode_changed(self, new_mode):
        self.set_tablet_widgets_sensitivity(new_mode)

    def set_tablet_widgets_sensitivity(self, mode):
        is_tablet_mode = mode == "TABLET"
        self.comboBoxOrientation.setEnabled(is_tablet_mode)
        self.spinBoxSize.setEnabled(is_tablet_mode)
        self.labelSize.setEnabled(is_tablet_mode)
        self.labelOrientation.setEnabled(is_tablet_mode)

    def set_mode_clicked(self):
        devpath = self.selected_devpath()
        new_mode = unicode(self.comboBoxMode.currentText())
        self.daemon.set_mode(devpath, new_mode)
        self.current_mode = new_mode
        if new_mode == "TABLET":
            size = self.spinBoxSize.value()
            orientation = unicode(self.comboBoxOrientation.currentText())
            self.daemon.set_tablet_settings(devpath, size, orientation)
        self.statusBar().showMessage("%s mode activated." % new_mode, 3000)

    def download_clicked(self):
        filename = QFileDialog.getSaveFileName(self, "Select download target")
        if filename:
            devpath = self.selected_devpath()
            # Just create the file if it does not exist. This should
            # to ensure that the file has a proper owner and a
            # group. m210-daemon is probably running under different
            # uid and will create the file if it does not exist.
            open(filename, "a").close()
            bytes = self.daemon.download_notes_to_file(devpath, unicode(filename))
            self.statusBar().showMessage("Downloaded %s bytes." % bytes, 3000)

    def erase_clicked(self):
        result = QMessageBox.question(self, "Erase all notes?",
                                      "Are you sure you want to erase all notes stored in the device?",
                                      QMessageBox.Yes | QMessageBox.No,
                                      QMessageBox.No)
        if result == QMessageBox.Yes:
            devpath = self.selected_devpath()
            self.daemon.delete_notes(devpath)
            self.spinBoxUsedMemory.setValue(0)

    def used_mem_changed(self, memory):
        b = bool(memory)
        self.pushButtonDownload.setEnabled(b)
        self.pushButtonErase.setEnabled(b)

    def table_selection_changed(self):
        devpath = self.selected_devpath()
        if not devpath:
            # Selection is empty.
            self.groupBox.setEnabled(False)
            self.clear_details()
            return
        try:
            self.update_details(devpath)
            self.groupBox.setEnabled(True)
        except dbus.exceptions.DBusException, e:
            name = e.get_dbus_name()
            if name != "org.freedesktop.DBus.Python.m210.daemon.NotConnectedError":
                raise e
            self.groupBox.setEnabled(False)

    def selected_devpath(self):
        try:
            selected_item = self.tableWidget.selectedItems()[0]
        except IndexError:
            return None
        return unicode(selected_item.data(Qt.DisplayRole).toString())

    def update_details(self, devpath):
        fw, analog, pad, mode, bytes = self.daemon.get_info(devpath)
        self.current_mode = mode
        self.spinBoxFirmwareVersion.setValue(fw)
        self.spinBoxAnalogVersion.setValue(analog)
        self.spinBoxPadVersion.setValue(pad)
        index = self.comboBoxMode.findText(mode)
        self.comboBoxMode.setCurrentIndex(index)
        self.spinBoxUsedMemory.setValue(bytes)
        self.set_tablet_widgets_sensitivity(mode)

    def clear_details(self):
        self.spinBoxFirmwareVersion.setValue(0)
        self.spinBoxAnalogVersion.setValue(0)
        self.spinBoxPadVersion.setValue(0)
        self.spinBoxUsedMemory.setValue(0)
        
    def device_erased(self, devpath):
        if self.devpath_to_item(devpath).isSelected():
            self.spinBoxUsedMemory.setValue(0)

    def devpath_to_item(self, devpath):
        return self.tableWidget.item(self.row_map[devpath], 0)

    def device_mode_changed(self, devpath, new_mode):
        if self.devpath_to_item(devpath).isSelected():
            index = self.comboBoxMode.findText(new_mode)
            self.comboBoxMode.setCurrentIndex(index)            

    def add_row(self, devpath, connected=False):
        row = self.tableWidget.rowCount()
        self.tableWidget.setRowCount(row + 1)
        devpath_item = QTableWidgetItem(devpath)
        devpath_item.setFlags(Qt.ItemIsSelectable
                              | Qt.ItemIsEnabled
                              | Qt.ItemIsDragEnabled)
        self.tableWidget.setItem(row, 0, devpath_item)
        checkbox = QCheckBox()
        checkbox.setChecked(connected)
        slot = functools.partial(self.device_connection_clicked, devpath)
        checkbox.clicked.connect(slot)
        self.tableWidget.setCellWidget(row, 1, checkbox)
        devpath_item.setSelected(True)
        self.row_map[devpath] = row

    def remove_row(self, devpath):
        self.tableWidget.removeRow(self.row_map.pop(devpath))

    def device_connection_clicked(self, devpath, connected):
        self.tableWidget.setCurrentCell(self.row_map[devpath], 1)
        if connected:
            self.daemon.connect(devpath)
        else:
            self.daemon.disconnect(devpath)

    def device_connection_changed(self, connected, devpath):
        row = self.row_map[devpath]
        self.tableWidget.cellWidget(row, 1).setChecked(connected)
        self.update_groupbox(row, devpath, connected)

    def update_groupbox(self, row, devpath, connected):
        item = self.tableWidget.item(row, 0)
        if item.isSelected():
            self.groupBox.setEnabled(connected)
            if connected:
                self.update_details(devpath)
            else:
                self.clear_details()

def main():
    app = QApplication(sys.argv)
    mw = MainWindow()
    mw.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
