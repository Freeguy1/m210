#!/usr/bin/python
# -*- coding: utf-8 -*-

# m210c
# Copyright © 2010 Tuomas Räsänen (tuos) <tuos@codegrove.org>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import print_function
from __future__ import division

# Standard modules.
import optparse
import os.path
import sys

# Third-party modules.
import dbus.exceptions

# Project modules.
import m210.daemon

def error_and_exit(msg):
    prog = os.path.basename(sys.argv[0])
    print("%s: error: %s" % (prog, msg), file=sys.stderr)
    sys.exit(1)

def connect(daemon, options, devpath):
    try:
        daemon.connect(devpath)
    except dbus.exceptions.DBusException, e:
        if e.get_dbus_name() == "org.freedesktop.DBus.Python.m210.daemon.AlreadyConnectedError":
            error_and_exit("%s is already connected" % devpath)
        raise e           

    if not options.quiet:
        print("+", devpath)

def disconnect(daemon, options, devpath):
    try:
        daemon.disconnect(devpath)
    except dbus.exceptions.DBusException, e:
        if e.get_dbus_name() == "org.freedesktop.DBus.Python.m210.daemon.NotConnectedError":
            error_and_exit("%s is not connected" % devpath)
        raise e           
    
    if not options.quiet:
        print("-", devpath)

def list_all(daemon, options, devpath):
    if devpath:
        devpaths = [devpath]
    else:
        devpaths = [devpath for (devpath, connected) in daemon.devpaths()]

    for devpath in devpaths:
        try:
            firmware, analog, pad, bytes = daemon.get_info(devpath)
        except dbus.exceptions.DBusException, e:
            name = e.get_dbus_name()
            if name == "org.freedesktop.DBus.Python.m210.daemon.NotConnectedError":
                print("- %s" % devpath)
                continue
            raise e
        print("+ %s" % devpath)
        print("  Firmware version:", firmware)
        print("  Analog version:  ", analog)
        print("  Pad version:     ", pad)
        print("  Used memory:     ", bytes)

def erase(daemon, options, devpath):

    def is_confirmed():
        while True:
            answer = raw_input("Really erase [y/n]? ")
            if answer == 'y':
                return True
            elif answer == 'n':
                return False
            else:
                print("Please answer y or n.")

    if not options.quiet:
        print("Preparing to erase %s" % devpath)

    if options.confirm_erasure and not is_confirmed():
        if not options.quiet:
            print("Aborted.")
        return

    try:
        daemon.delete_notes(devpath)
    except dbus.exceptions.DBusException, e:
        if e.get_dbus_name() == "org.freedesktop.DBus.Python.m210.daemon.NotConnectedError":
            error_and_exit("%s is not connected" % devpath)
        raise e

    if not options.quiet:
        print("Erased.")

def download(daemon, options, devpath):
    if options.file:
        target = open(options.file, "wb")
    else:
        target = sys.stdout
    try:
        print(daemon.download_notes(devpath, byte_arrays=True), end="", file=target)
    except dbus.exceptions.DBusException, e:
        if e.get_dbus_name() == "org.freedesktop.DBus.Python.m210.daemon.NotConnectedError":
            error_and_exit("%s is not connected" % devpath)
        raise e

def enable(daemon, options, devpath):
    daemon.set_input_enabled(devpath, True)
    daemon.set_tablet_settings(devpath, int(options.size), options.orient)

def disable(daemon, options, devpath):
    daemon.set_input_enabled(devpath, False)

COMMAND_MAP = {
    'connect': connect,
    'disconnect': disconnect,
    'list': list_all,
    'erase': erase,
    'download': download,
    'enable': enable,
    'disable': disable,
}

class MyFormatter(optparse.IndentedHelpFormatter):

    def format_description(self, description):
        return description or ""

    def format_epilog(self, epilog):
        return epilog or ""

def main():
    parser = optparse.OptionParser(usage='%prog [OPTION]... COMMAND [OPTION]... [DEVPATH]',
                                   version=m210.VERSION_TEXT,
                                   description="""Client for m210d.

Commands:
  connect              connect DEVPATH or last plugged device to m210d
  disconnect           disconnect DEVPATH or last plugged device from m210d
  download             download notes from DEVPATH or last plugged device
  erase                erase notes from DEVPATH or last plugged device
  enable               enable tablet of DEVPATH or last plugged device
  disable              disable tablet of DEVPATH or last plugged device
  list                 list all plugged devices and details about connected ones
""",
                                        epilog="""
Usage examples:

  Ask to list devices but there is not any plugged in:

    $ m210c list
    m210c: error: no devices found

  Once a device is plugged in, it can be listed:

    $ m210c list
    - /sys/devices/pci0000:00/0000:00:1d.1/usb6/6-1

  Hyphen at the beginning of the line indicates that the device is
  plugged in but not connected to m210d. /sys/devices/... is the filepath
  to the device (DEVPATH).

  Connect a device to m210d:

    $ m210c connect
    + /sys/devices/pci0000:00/0000:00:1d.1/usb6/6-1

  Plus-sign at the beginning of the line indicates that device is now
  connected. Connect command accepts a device filepath (DEVPATH as an
  argument, but if omitted, it will connect the last plugged device.

  If trying to connect the same device twice, following error message
  appears:

    $ m210c connect
    m210c: error: /sys/devices/pci0000:00/0000:00:1d.1/usb6/6-1 is already connected

  List all devices and details about connected ones:

    $ m210c list
    + /sys/devices/pci0000:00/0000:00:1d.1/usb6/6-1
      Firmware version: 337
      Analog version:   265
      Pad version:      32028
      Used memory:      20956

  If DEVPATH is given, then show information only on that device.

  Download notes from a device:

    $ m210c download --output=target_file_name

  As usual, if DEVPATH is omitted, download notes from the last
  plugged device. In most cases, this is the right thing to do,
  because normally only one device connected to the system.
    
  If --output option is omitted, notes will be printed to stdout.

  Erase notes from a device:

    $ m210c erase
    Preparing to erase /sys/devices/pci0000:00/0000:00:1d.1/usb6/6-1
    Really erase [y/n]?

  Erase command will confirm the erasure by default. This can be
  suppressed with --no-confirmation option.

  Disconnect a device:

    $ m210c disconnect
    - /sys/devices/pci0000:00/0000:00:1d.1/usb6/6-1

  Enable tablet:

    $ m210c enable --size=0 --orient=N

  Disable tablet:

    $ m210c disable

""",
                                        formatter=MyFormatter())

    parser.add_option("--quiet", "", action="store_true", default=False,
                      help="do not print any processing messages to stdout")

    erase_group = optparse.OptionGroup(parser, "Erase Options")
    erase_group.add_option("--no-confirmation", "", action="store_false",
                           dest="confirm_erasure", default=True,
                           help="do not ask confirmation for erasure")
    parser.add_option_group(erase_group)

    download_group = optparse.OptionGroup(parser, "Download Options")
    download_group.add_option("--output", "", dest="file",
                              help="download notes to FILE instead of stdout")
    parser.add_option_group(download_group)

    enable_group = optparse.OptionGroup(parser, "Enable Options")
    enable_group.add_option("--size", "", dest="size",
                            choices=[str(v) for v in range(10)],
                            default="5",
                            help="set size to 0-9, default=5")
    enable_group.add_option("--orient", "", dest="orient",
                           choices=["NW", "N", "NE"], default="N",
                           help="set orientation to 'NW', 'N' or 'NE', default='N'")
    parser.add_option_group(enable_group)

    options, args = parser.parse_args(sys.argv)

    try:
        cmd_name = args[1]
    except IndexError:
        parser.print_usage()
        error_and_exit("missing command")

    try:
        cmd_fn = COMMAND_MAP[cmd_name]
    except KeyError:
        error_and_exit("%s is invalid command" % cmd_name)

    cmd_args = args[2:]

    try:
        daemon = m210.daemon.Interface()
    except dbus.exceptions.DBusException, e:
        if e.get_dbus_name() == "org.freedesktop.DBus.Error.ServiceUnknown":
            error_and_exit("%s is not available" % m210.daemon.NAME)
        raise e

    try:
        devpath = cmd_args[0]
    except IndexError:
        try:
            devpath, connected = daemon.devpaths()[-1]
        except IndexError:
            error_and_exit("no devices found")

    try:
        cmd_fn(daemon, options, devpath)
    except dbus.exceptions.DBusException, e:
        if e.get_dbus_name() == "org.freedesktop.DBus.Python.m210.daemon.UnknownDeviceError":
            error_and_exit("%s is not supported device" % devpath)
        raise e

if __name__ == "__main__":
    main()
